---
layout: post
title: Android编码解码及其原理
category: Android
tags:
  - Android
  - AndroidTips

abbrlink: 438600076
date: 2015-05-11 00:00:00
keywords:
---


## 前言
1. 本文用到ASCII表，Base64对照表请自行百度。

2. 概念：编码解码就是使用特定的算法，将数据进行处理，形成数据的另外一种表现形式，编码后的数据可以使用解码算法还原出原始数据。

## Base64简介

- Base64算法可以将**任意的字节数组数据**通过算法生成只有（英文大小写，数字，+，/）共64种字符的字符串数据；相当于将任意内容转换为可见字符串表示。

- 也就是将不可见的数据转换为ASCII码数据，便于在Json和Xml中传递。

## Base64Api
```java
//将字节数组编码，返回为String
Base64.encodeToString(byte[] bs,int flag);
//将字节数组编码，返回字节数组
Base64.encode(byte[] bs,int flag);
//将字节数组按指定位置部分编码，返回字符串
Base64.encodeToString(byte[] bs,int offset,int lenth);
//将字节数组按指定位置部分编码，返回字节数组
Base64.encode(byte[] bs,int offset,int lenth);
//将编码后的字符串解码返回字节数组
Base64.decode(String str,int flag);
//将编码后的字节数组解码返回字节数组
Base64.decode(byte[],int flag);
//将编码后的字节数组按指定位置部分解码，返回字节数组
Base64.decode(byte[] bs,int offset,int len);
```

## flag常量

```
Base64.CRLF	这个参数意思是Win风格的换行符，意思就是使用CR LF这一对作为一行的结尾而不是Unix风格的LF

Base64.DEFAULT 这个参数是默认，使用默认的方法来加密

Base64.NO_PADDING 这个参数是略去加密字符串最后的”=”

Base64.NO_WRAP 这个参数意思是略去所有的换行符（设置后CRLF就没用了）

Base64.URL_SAFE 这个参数意思是加密时不使用对URL和文件名有特殊意义的字符来作为加密字符，具体就是以-和_取代+和/

//习惯上使用Base64.NO_WRAP，使用什么方式编码就需要使用什么方式解码。
```
## Base64原理

- Base64在编码时按照三个字节一组分组， 进行处理，每三个字节在编码之后被转换为4个字符。

1. 每个字节有8个bit(也必须是要求有8bit，所以中文是不可以的),三个字节就有24个bit.

2. 但是我们只有64 种字符选择，也就是Base64的字符最多只能用6bit来表示，再大就会超出64的范围，所以编码以后显示的字符开始两位是0.

3. 那么原先24bit的数据要显示在现在每个字符只有6bit的表示方法上，很明显需要4个字符（3\*8 == 4\*6）

4. 当数据长度在无法满足3的倍数的时候会在末尾添加“=“
具体的转换方法直接说可能有点抽象，

## 字符串Base64编码过程

- 字符串`String str = "0Aa";`首先，原先每个字符是2个字节16bit,对于英文来说前8个bit是0，也就是只有8个bit,现在是3个字符，3*8=24个bit需要显示。



- 转换

| get   |     0 | A |a |
| :-------- | :--------:|  :--------: | :--------: |
| ASCII   |  48|  65|97 |
| 二进制表示  |  00110000|  01000001|01100001|


- 现在拼凑成是这样的二进制串( 001100   000100  000101   100001)，将其转化为Base64可以显示的模式，需要每次取6位作为一个Base64字符,前两位补0

|get    |    1|   2   | 3|   4   |
| :-------- |  :--------:| :--------:| :--------:|  :--------: |
| 开始  |    001100|    000100  | 000101  |   100001  |
|转化 |    00001100|    00000100  | 00000101  |   00100001  |
|转为10进制|    12|   4| 5 |   33 |
|Base64字符|   M|   E| F|  h |



## 二进制数组编码过程
- 这个例子已经很清晰的解释了Base64的编码过程，网上有人自己实现了Base64编码的类，android源码也不难，这是编码字符串看起来还是比较清晰的，我们也可以更本质一点

- `byte[] bs = new byte[]{1,10,20};`这是一个byte数组，复习一下，1个byte是8个bit,可以表示的范围0-127之间，我们在调用Base64的函数时，本质也是在操作字节数组，同样的原理

| byte |     1 | 10|20 |
| :-------- |:--------:|:--------: |:--------:|
| 二进制表示  |  00000001|  00001010|00010100|



- 6位一组，二进制串000000    010000   101000    010100

|get    |    1|   2   | 3|   4   |
| :-------- | :--------:| :--------: |:--------:| :--------: |
| 开始  |    000000    |  010000 | 101000   |   010100|
|转化  |    00000000    |  00010000 | 00101000   |   00010100|
|转为10进制|   0|   16| 40 |   20 |
|Base64字符|   A|   Q|o|  U |



## Hex编码简介

1. Hex就是16进制，本质上是将字节数组转化为16进制，然后用字符串的形式表现出来，我们知道16进制的取值范围就是在0-f之间，这样就可以将无法显示的字节数组数据显示出来。


2. 原理方面比起Base64就简单很多了，一个8bit的数据，也就是（xxxx xxxx）,每4个bit可以转化为一个16进制表示，也就是8个bit会转化为（00-ff）之间的16进制数字。

## Hex编码实现
```java
 /**
     * 字节数组转换为字符串
     * 一个字节形成两个字符，是原来数据长度的两倍
     *
     * @param data
     * @return
     */
    public static String toHex(byte[] data) {
        String ret = null;
        //todo 将字节数组转换为字符串
        if (data != null && data.length > 0) {
            StringBuilder sb = new StringBuilder();
            for (byte b : data) {
                //分别获取高四位和低四位转换为字符
                int h = (b >> 4) & 0x0f;
                int l = b & 0x0f;
                char ch, cl;
                if (h > 9) {//0x0a~0x0f
                    ch = (char) ('A' + (h - 10));
                } else {//0~9
                    ch = (char) ('0' + h);
                }

                if (l > 9) {//0x0a~0x0f
                    cl = (char) ('A' + (l - 10));
                } else {//0~9
                    cl = (char) ('0' + l);
                }
                sb.append(ch).append(cl);
            }
            ret = sb.toString();
        }
        return ret;
    }
```
## Hex编码原理分析
- 简单说一下，&运算，两者都为1结果才是1，b>>4&0xf取出高四位，b&0x0f取出低四位，举个例子：
- 字节是      b   =    1010 1111
- b>>4     b = 00001010
- b>>4&0x0f 也就是   00001010&00001111 ----> 1010高四位取出来了，取得低四位原理一样。后面的操作就是根据数据的大小转换一下格式，因为拿到的数据是十进制的那么范围会在0-15之间，需要转换为16进制的0-f.

## Hex解码实现
```
/**
     * 将编码字符串解码为字节数组
     *
     * @param data
     * @return
     */
    public static byte[] fromHex(String data) {

        byte[] ret = null;
        //todo 将字符串转换为字节数组
        if (data != null) {
            int len = data.length();
            char[] chs = data.toCharArray();
            ret = new byte[len/2];
            int ih = 0,il=0,v=0,j=0;
            if (len > 0 && len % 2 == 0) {
                for (int i = 0; i < len - 1; i += 2,j++) {
                    char ch = chs[i];
                    char cl = chs[i+1];

                    if(ch>='A'&&ch<='F'){
                        ih = 10 + (ch - 'A');
                    }else if(ch >='a'&&ch<='f'){
                        ih = 10 + (ch - 'a');
                    }else if(ch>'0'&&ch<='9'){
                        ih = ch - '0';
                    }

                    if(cl>='A'){
                        il = 10 + (cl - 'A');
                    }else if(cl >='a'){
                        il = 10 + (cl - 'a');
                    }else if(cl>'0'){
                        il = cl - '0';
                    }
                    v = ((ih&0x0f)<<4)|(il&0x0f);
                    ret[j] = (byte)v;

                }
            }
        }
        return ret;
    }
```

## Hex解码原理分析
- 相当于编码的逆运算，根据字符串每次取两位，转换成int，在进行移位将其拼成一个字节，怎么拼的？`v = ((ih&0x0f)<<4)|(il&0x0f);`


- 这一句，假设我们获得的字符串最后转化结果是10和5，也就是1010，0101。10<<4,结果是10100000，然后10100000 | 0101，|运算只要有1则为1，结果是10100101就完成了拼接工作。


## 总结
- Base64和Hex是比较常见的编码方式，对比一下，Base64每3个字节转化为4个字节，每个字节浪费2bit,Hex编码，每个字节转化为两个字节，每个字节浪费4bit,所以说Base64更加节省空间，而且用起来简单得多。